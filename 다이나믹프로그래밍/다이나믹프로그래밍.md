# 다이나믹 프로그래밍(동적 계획법)

## 피보나치 함수
```py
def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x - 1) + fibo(x - 2)
```
위와 같은 피보나치 수열의 시간 복잡도를 세타 표기법을 사용하여 나타내면 θ(1.6118…ⁿ)으로 N이 30이면 약 10억 가량의 연산을 해야되고, N이 100이면 수백억 년을 계산해야 된다. 

이러한 문제는 다이나믹 프로그래밍을 사용하면 효율적으로 해결할 수 있다. 다망 항상 다이내믹 프로그래밍을 사용할 수는 없고, 다음 조건을 만족할 때 사용할 수 있다. 
 1. 큰 문제를 작은 문제로 나눌 수 있다. 
 2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다. 

피보나치 수열은 이러한 조건을 만족하는 대표 문제이다. 이 문제는 메모이제이션 기법을 사용해서 해결할 수 있는데, 이 때 메모이제이션은 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법을 말한다. 메모이제이션 값을 저장하는 방법으로 캐싱이라고도 한다. 
```py
# 한 번 계산된 결과를 메모이제이션하기 위한 리스트 초기화
d = [0] * 100

# 피보나치 함수를 재귀함수로 구현(탑다운 다이나믹 프로그래밍)
def fibo(x): 
    # 종료 조건(1 혹은 2일 때 1을 반환)
    if x == 1 or x == 2:
        return 1
    # 이미 계산한 적 있는 문제라면 그대로 반환
    if d[x] != 0:
        return d[x]
    # 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
    d[x] = fibo(x - 1) + fibo(x - 2)
    return d[x]

print(fibo(99))
```
퀵 정렬은 정렬을 수행할 때 리스트를 분할하며 전체적으로 정렬이 될 수 있도록 하는데, 이를 분할 정복(Divide and Conquer) 알고리즘으로 분류된다. 다이나믹 프로그래밍과 분할 정복의 차이점은 다이나믹 프로그래밍은 문제들이 서로 영향을 미치고 있다는 점이다. 퀵 정렬을 예로 들면, 한 번 기준 원소(pivot)이 자리를 잡으면 더 이상 변하지 않고, 그 피벗값을 다시 처리하는 부분 문제는 존재하지 않는다. 반면 다이나믹 프로그래밍은 결과를 저장해 놓았다가 나중에 동일한 문제를 풀어야 할 때 이미 저장한 값을 반환한다.  

이처럼 재귀 함수를 이용하여 다이나믹 프로그래밍 소스코드를 작성하는 방법을 큰 문제를 해결하기 위해 작은 문제를 호출한다고 하여 탑다운(Top-Down) 방식이라고 말한다. 반면에 단순히 반복문을 이용하여 소스코드를 작성하는 경우 작은 문제부터 차근차근 답을 도출한다고 하여 보텀업(Bottom-Up) 방식이라고 말한다. 
```py
d = [0] * 100

d[1] = 1
d[2] = 2
n = 99

for i in range(3, n + 1):
    d[i] = d[i - 1] + d[i - 2]

print(d[n])
```
탑다운(메모이제이션) 방식은 하향식이라고도 하며, 보텀업 방식은 상향식이라고도 한다. 다이나믹 프로그래밍의 전형적인 형태는 보텀업 방식이다. 보텀업 방식에서 사용되는 결과 저장용 리스트는 'DP 테이블'이라고 부르며, 메모이제이션은 탑다운 방식에 국한되어 사용되는 표현이다.  